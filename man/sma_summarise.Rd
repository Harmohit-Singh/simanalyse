% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simanalyse-summarise.R
\name{sma_summarise}
\alias{sma_summarise}
\title{Apply R code to each element of an nlist object. This can be used to derive new variables or create some missing data in the simulated data 
or in the results of the analyses.}
\usage{
sma_summarise(object, code, measures = c("mean", "lower.q", "upper.q"),
  parameters = "", monitor = ".*", alpha = 0.05,
  custom_funs = list())
}
\arguments{
\item{object}{A list of nlists object of results or a single nlists of results.}

\item{code}{A string of R code to derive posterior samples for new parameters. E.g. "var = sigma^2".}

\item{measures}{A vector of strings indicating which functions to calculate over the mcmc samples. Strings may include "mean", 
"median", "lower.q" (lower bound of the quantile-based credible interval), "upper.q" (upper bound of the quantile-based 
credible interval), "var", "sd", "q1" (1st quartile), "q3" (3rd quartile)}

\item{parameters}{An nlist of the true values of the parameters in \code{object}. Optional, but must be passed if \code{sma_performance} is to be used.}

\item{monitor}{A character vector (or regular expression if a string) specifying the names of the variables in \code{object} and/or \code{code} to monitor. By default all variables are included.}

\item{alpha}{scalar representing the alpha level used to construct credible intervals. Default is 0.05.}

\item{custom_funs}{A named list of functions to calculate over the mcmc samples. This optional argument can be used to calculate
measures that cannot be specified through \code{measures}. E.g. list(posteriormedian = median).}
}
\value{
A flag.
}
\description{
Derive new variables from the results of analyses
}
\examples{
set.seed(10L)
code <- "for(i in 1:10){x[i] ~ dnorm(0,1/variance)}"
dat <- sims::sims_simulate(code, parameters = nlist(variance=4), nsims=2)
res <- sma_analyse_bayesian(dat, code, code.add = "variance ~ dunif(0,10)", 
n.adapt=100, n.burnin=0, n.iter=3, monitor="variance")
sma_summarise(res, "sd=sqrt(variance)")
}
